/////1
gdb ./bomb
(gdb) break phase_1
(gdb) run
(gdb) disas phase_1
(gdb) x/s 0x402400
(gdb) quit
./bomb
Ответ: Border relations with Canada have never been better.

/////2
gdb ./bomb
disas phase_2
call 0x40145c <read_six_numbers>
нужно ввести 6 чисел

Функция read_six_numbers
Загружает 6 чисел в память (%rsp).
Если не удалось считать 6 чисел, вызывает explode_bomb().
Проверка первого числа
cmpl $0x1, (%rsp) ; сравнивает первое число с 1
Если не 1, бомба взрывается
Цикл проверок
rbx перебирает оставшиеся числа
Следующее число должно быть в 2 раза больше предыдущего:
mov -0x4(%rbx), %eax ; загружает предыдущее число
add %eax, %eax ; умножает на 2
cmp %eax, (%rbx) ; сравнивает с текущим
Если не совпадает → explode_bomb()

По условию первое число 1, затем каждое следующее в 2 раза больше
значит: 1 2 4 8 16 32

/////3
(gdb) break phase_3
(gdb) run
(gdb) disas phase_3
Анализ sscanf
call 0x400bf0 <__isoc99_sscanf@plt>
cmp $0x2,%eax
jne 0x401035 <phase_3+41>
Это означает, что программа ждет два числа. Если sscanf считал не два числа, вызывается explode_bomb

Определение нужных чисел
Дальше идет проверка первого числа:

cmp $0x7,%edi ; проверка диапазона
ja 0x401035 ; если больше 7 — взрыв
Это значит, что первое число должно быть от 0 до 7

Далее идет таблица переходов (switch-case), где программа выполняет разные команды в зависимости от значения
Используем gdb для проверки:
(gdb) print $edi
и
(gdb) print $esi
чтобы увидеть, что проверяется

Если в phase_3 есть числа x и y, попробуем ввод:
1 311
Работает!

/////4
gdb ./bomb
break phase_4
run
disas phase_4

что делает phase_4:
Считывает два числа
Проверяет диапазон (0 ≤ X ≤ 14)
Вызывает func4(X, 0, 14)
Проверяет, что func4 вернула 0
Проверяет, что второе число Y == 0

Дизассемблируем func4. Она рекурсивно ищет середину и сравнивает с X
disas func4

Проверяем, какие значения передаются в func4
break \*0x400fce

Останавливаемся в начале func4 и смотрим, какие аргументы передаются
и печатаем их:
print $rdi # X (первое число)
print $rsi # 0 (начальный low)
print $rdx # 14 (начальный high)
Если X == 7, функция сразу вернет 0, и фаза пройдет

run

7 0
Работает!!!

/////5
Запускаем gdb и устанавливаем точку останова перед phase_5
gdb ./bomb
break phase_5
run

Мы это делаем чтобы остановить выполнение перед phase_5 и изучить её логику

Дизассемблируем phase_5
disas phase_5
Читает одно число X (с sscanf)
Дальше использует X в and 0xf (аналогично X % 16)
Затем использует это значение в массиве или вызывает проверку

Ставим точку останова перед проверкой
break \*0x4010XX # Тут адрес перед проверкой
continue

Останавливаемся перед критической проверкой, чтобы посмотреть, что проверяется
и печатаем
print $rdi # Значение X

Если используется and 0xf, X должен быть в диапазоне 0–15

Запускаем
run

Вывод:
ionefg

Работает!!!

/////6
break phase_6
run

Дизассемблируем phase_6, чтобы понять, что она делает
disas phase_6

Ищем ключевые функции, которые могут быть важны. Например, если в коде вызывается какая-то другая функция (например, func6), то дизассемблируем и её
disas func6

Разбираем структуру входных данных
Если phase_6 использует scanf, смотрим, сколько аргументов вводится. Можно использовать
info registers
print _(int _)($rsp+8)
print *(int *)($rsp+12)

Читает 6 чисел (вызов read_six_numbers)
0x0000000000401106 <+18>: call 0x40145c <read_six_numbers>

Наши числа будут храниться на стеке в rsp
Проверяем каждое число
0x0000000000401117 <+35>: mov 0x0(%r13),%eax # Загружаем число
0x000000000040111b <+39>: sub $0x1,%eax # Уменьшаем на 1
0x000000000040111e <+42>: cmp $0x5,%eax # Сравниваем с 5
0x0000000000401121 <+45>: jbe 0x401128 <phase_6+52> # Если в диапазоне [1,6] → ОК

Все числа должны быть в диапазоне [1,6]
Проверяем, что все числа уникальны
0x000000000040113b <+71>: cmp %eax,0x0(%rbp)
0x000000000040113e <+74>: jne 0x401145 <phase_6+81>
0x0000000000401140 <+76>: call 0x40143a <explode_bomb>

Если одно из чисел уже встречалось бомба взорвётся

Числа используются как индексы в связанном списке
Скорее всего, дальше идёт обход списка и проверка порядка.

Из-за особенностей списка правильный ввод должен быть:
4 3 2 1 6 5

run
4 3 2 1 6 5

Работает!!!
